#!/usr/bin/env bash
# This script was generated by bashly (https://github.com/DannyBen/bashly)
# Modifying it manually is not recommended

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
alf_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf - Your Little Bash Alias Friend\n"
    echo 
  else
    printf "alf - Your Little Bash Alias Friend\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  alf [command]\n"
  printf "  alf [command] --help | -h\n"
  printf "  alf --version | -v\n"
  echo
  # :command.usage_commands
  printf "Commands:\n"
  echo "  connect    Connect to a remote git repository"
  echo "  download   Perform git pull on the connected repo"
  echo "  upload     Perform git commit and push on the connected repo"
  echo "  generate   Generate aliases to stdout"
  echo "  save       Generate aliases to ~/.bash_aliases"
  echo "  edit       Open your alf.conf for editing"
  echo "  which      Show the alias command"
  echo "  upgrade    Upgrade alf to the latest version"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    echo "  --version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"
    
    # :environment_variable.usage
    echo "  ALF_RC_FILE"
    printf "    Path to alfrc file\n    This file holds the path to the alf-conf repository\n    Default: ~/.alfrc\n"
    echo

  fi
}

# :command.usage
alf_connect_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf connect - Connect to a remote git repository\n"
    echo 
  else
    printf "alf connect - Connect to a remote git repository\n"
    echo 
  fi

  printf "Shortcut: c\n"
  echo

  printf "Usage:\n"
  printf "  alf connect REPO [options]\n"
  printf "  alf connect --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo
    # :command.usage_flags
    # :flag.usage
    echo "  --ssh"
    printf "    Connect to GitHub non-interactively using SSH (implies --yes)\n"
    echo
    
    # :flag.usage
    echo "  --https"
    printf "    Connect to GitHub non-interactively using HTTPS (implies --yes)\n"
    echo
    
    # :flag.usage
    echo "  --yes, -y"
    printf "    Connect to any remote repository non-interactively\n"
    echo
    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  REPO"
    printf "    Remote GitHub repository to connect to. This can be one of:\n    \n    - Your username on GitHub. In this case, the repository is expected to\n      be named 'alf-conf'\n    - Your username/repo on GitHub\n    - Any other full URL to a repository\n"
    echo

    # :command.usage_examples
    printf "Examples:\n"
    
    printf "  alf connect you --ssh\n"
    printf "  alf connect you/alf-config\n"
    printf "  alf connect https://You@bitbucket.org/YourUser/rush-repo.git --yes\n"
    echo

  fi
}

# :command.usage
alf_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf download - Perform git pull on the connected repo\n"
    echo 
  else
    printf "alf download - Perform git pull on the connected repo\n"
    echo 
  fi

  printf "Shortcut: d\n"
  echo

  printf "Usage:\n"
  printf "  alf download\n"
  printf "  alf download --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_upload_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf upload - Perform git commit and push on the connected repo\n"
    echo 
  else
    printf "alf upload - Perform git commit and push on the connected repo\n"
    echo 
  fi

  printf "Shortcut: u\n"
  echo

  printf "Usage:\n"
  printf "  alf upload\n"
  printf "  alf upload --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf generate - Generate aliases to stdout\n"
    echo 
  else
    printf "alf generate - Generate aliases to stdout\n"
    echo 
  fi

  printf "Shortcut: g\n"
  echo

  printf "Usage:\n"
  printf "  alf generate\n"
  printf "  alf generate --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_save_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf save - Generate aliases to ~/.bash_aliases\n"
    echo 
  else
    printf "alf save - Generate aliases to ~/.bash_aliases\n"
    echo 
  fi

  printf "Shortcut: s\n"
  echo

  printf "Usage:\n"
  printf "  alf save\n"
  printf "  alf save --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_environment_variables
    printf "Environment Variables:\n"
    
    # :environment_variable.usage
    echo "  ALF_ALIASES_FILE"
    printf "    Path to bash_aliases file\n    Aliases will be saved to this file\n    Default: ~/.bash_aliases\n"
    echo

  fi
}

# :command.usage
alf_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf edit - Open your alf.conf for editing\n"
    echo 
  else
    printf "alf edit - Open your alf.conf for editing\n"
    echo 
  fi

  printf "Shortcut: e\n"
  echo

  printf "Usage:\n"
  printf "  alf edit\n"
  printf "  alf edit --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_which_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf which - Show the alias command\n"
    echo 
  else
    printf "alf which - Show the alias command\n"
    echo 
  fi

  printf "Shortcut: w\n"
  echo

  printf "Usage:\n"
  printf "  alf which CODE [SUBCODE]\n"
  printf "  alf which --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "Arguments:\n"
    
    # :argument.usage
    echo "  CODE"
    printf "    Show the command for this alias code\n"
    echo
    
    # :argument.usage
    echo "  SUBCODE"
    printf "    Show the command for this alias sub-code\n"
    echo

  fi
}

# :command.usage
alf_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf upgrade - Upgrade alf to the latest version\n"
    echo 
  else
    printf "alf upgrade - Upgrade alf to the latest version\n"
    echo 
  fi

  printf "Usage:\n"
  printf "  alf upgrade\n"
  printf "  alf upgrade --help | -h\n"
  echo

  if [[ -n $long_usage ]]; then
    printf "Options:\n"
    # :command.usage_fixed_flags
    echo "  --help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.inspect_args
inspect_args() {
  echo args:
  for k in "${!args[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
}

# :command.user_lib
# :src/lib/find_config.sh
find_config() {
  repo_path="$PWD/alf-conf"
  config_file="alf.conf"
  if [[ -f $rc_file ]]; then
    repo_path=$(<"$rc_file")
    config_file=$repo_path/alf.conf
  fi

  if [[ ! -f $config_file ]]; then
    printf "ERROR: Cannot find config file\n\n"
    echo "You should either:"
    echo "- Run this command in a folder with 'alf.conf' file, or"
    echo "- Run 'alf connect' to properly connect to a remote config"
    exit 1
  fi
}

# :src/lib/generate_completion.sh
generate_completions() {
  ali1_regex="^([a-z0-9\-]+):"
  ali2_regex="^ +([a-z0-9\-]+):"
  find_config

  echo "# Completions"

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $ali1_regex ]]; then
      ali="${BASH_REMATCH[1]}"
      [[ -n $comp ]] && echo "complete -W $comp"
      comps=""
      comp=""
    elif [[ $line =~ $ali2_regex ]]; then
      if [[ -n $comps ]] ; then
        comps="$comps ${BASH_REMATCH[1]}"
      else
        comps="${BASH_REMATCH[1]}"
      fi
      comp="\"$comps\" $ali"
    fi
  done < "$config_file"
  
  if [[ -n $comp ]] && [[ -n $comps ]] ; then
    echo "complete -W $comp"
  fi
}

# :src/lib/generate_config.sh
generate_config() {
  regex="^( *)([a-z0-9\-]+): *(.+)$"
  cond="if"
  lastcmd=""
  find_config

  echo "# This file was automatically generated by alf"
  echo "# https://github.com/dannyben/alf"

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      indent="${BASH_REMATCH[1]}"
      
      if [[ -z $indent ]]; then
        ali1="${BASH_REMATCH[2]}"
        cmd1="${BASH_REMATCH[3]}"
        local_regex="^$ali1( +|$)"
        if [[ $cmd1 =~ $local_regex ]]; then
          cmd1="command $cmd1"
        fi
        unset ali2 cmd2
        generate_last_cmd
        lastcmd=$cmd1
      else
        ali2="${BASH_REMATCH[2]}"
        cmd2="${BASH_REMATCH[3]}"
      fi

      if [[ -n $ali2 ]]; then
        echo "  $cond [[ \$1 = \"$ali2\" ]]; then"
        echo "    shift"
        
        if [[ $cmd2 =~ ^! ]]; then
          cmd=${cmd2:1}
        elif [[ $cmd1 =~ ^! ]]; then
          cmd="$cmd2"
        else
          cmd="$cmd1 $cmd2"
        fi

        if [[ $cmd2 =~ \$ ]]; then
          echo "    $cmd"
        else
          echo "    $cmd \"\$@\""
        fi
        cond="elif"
      else
        echo ""
        echo "unalias $ali1 1>/dev/null 2>&1"
        echo "$ali1() {"
      fi
    fi
  done < "$config_file"
  generate_last_cmd

  echo ""
  generate_completions
}

# :src/lib/generate_last_cmd.sh
generate_last_cmd() {
  if [[ -n $lastcmd ]]; then
    if [[ $lastcmd =~ ^! ]]; then
      fullcmd="echo this alias requires a subcommand"
    elif [[ $lastcmd =~ \$ ]]; then
      fullcmd=$lastcmd
    else
      fullcmd="$lastcmd \"\$@\""
    fi

    if [[ $cond = "if" ]]; then
      echo "  $fullcmd"
      echo "}"
    else
      echo "  else"
      echo "    $fullcmd"
      echo "  fi"
      echo "}"
      cond="if"
    fi
  fi
}

# :src/lib/save_config.sh
save_config() {
  find_config

  echo "Saving to $aliases_file"
  generate_config > "$aliases_file"

  echo "To apply the new aliases to the current session, run:"
  echo "$ source ~/.bash_aliases"
}

# :command.command_functions
# :command.function
alf_connect_command() {
  # :src/connect_command.sh
  repo=${args[repo]}
  force=${args[--yes]}
  force_ssh=${args[--ssh]}
  force_https=${args[--https]}
  
  if [[ $repo =~ ':' ]]; then
    repo_url=$repo
  elif [[ $repo =~ '/' ]]; then
    partial_github_url=1
    repo_url="$repo.git"
  else
    partial_github_url=1
    repo_url="$repo/alf-conf.git"
  fi
  
  if [[ $force_ssh ]]; then
    answer=y
    [[ $partial_github_url ]] && repo_url="git@github.com:$repo_url"
    echo "Connecting to $repo_url"
  
  elif [[ $force_https ]]; then
    answer=y
    [[ $partial_github_url ]] && repo_url="https://github.com/$repo_url"
    echo "Connecting to $repo_url"
  
  elif [[ $force ]] ; then
    if [[ $partial_github_url ]] ; then
      echo "Error: Cannot determine the full URL for the repository"
      echo "To connect to GitHub use --ssh or --https"
      echo "To connect to another repository, provide the full URL"
      exit 1
    fi
    answer=y
    echo "Connecting to $repo_url"
  
  else
    echo "This operation will:"
    echo ""
    if [[ ! -d ./alf-conf ]]; then
      echo "  clone  $repo_url"
      echo "     to  ./alf-conf"
      echo ""
    fi
    echo "  write  $PWD/alf-conf"
    echo "     to  $rc_file"
    echo ""
  
    if [[ -n "$partial_github_url" ]]; then
      echo "Would you like to connect to GitHub via SSH or HTTPS?"
      echo ""
      printf "[S]SH, [H]TTPS or [A]bort (default): "
      read -r answer
      
      if [[ $answer =~ [Ss] ]]; then
        repo_url="git@github.com:$repo_url"
        answer=y
        echo ""
        echo "Using $repo_url"
      elif [[ $answer =~ [Hh] ]]; then
        repo_url="https://github.com/$repo_url"
        answer=y
        echo ""
        echo "Using $repo_url"
      fi
    else
      printf "Continue? [yN] "
      read -r answer
    fi
  fi
  
  if [[ $answer =~ [Yy] ]]; then
    if [[ -d ./alf-conf ]]; then
      echo "Skipping clone, directory already exists"
    else
      git clone "$repo_url" ./alf-conf
    fi
    echo "$PWD/alf-conf" > "$rc_file"
    echo "Storing location in $rc_file"
  else
    echo "Aborting"
    exit
  fi
  
  save_config
}

# :command.function
alf_download_command() {
  # :src/download_command.sh
  find_config
  
  if [[ ! -f $rc_file ]]; then
    echo "Cannot find $rc_file"
    echo "Please connect alf to a repository first"
    exit 1
  fi
  
  pushd "$repo_path" > /dev/null
  echo "Pulling from repository to $repo_path"
  git pull
  popd > /dev/null
  
  save_config
}

# :command.function
alf_upload_command() {
  # :src/upload_command.sh
  find_config
  
  if [[ ! -f $rc_file ]]; then
    echo "Cannot find $rc_file"
    echo "Please connect alf to a repository first"
    exit 1
  fi
  
  pushd "$repo_path" > /dev/null
  echo "Pushing $repo_path to repository"
  git commit -am "automatic push"
  git push
  popd > /dev/null
}

# :command.function
alf_generate_command() {
  # :src/generate_command.sh
  generate_config
}

# :command.function
alf_save_command() {
  # :src/save_command.sh
  save_config
}

# :command.function
alf_edit_command() {
  # :src/edit_command.sh
  find_config
  ${EDITOR:-vi} "$config_file"
}

# :command.function
alf_which_command() {
  # :src/which_command.sh
  code=${args[code]}
  subcode=${args[subcode]}
  
  find_config
  regex_exact_code="^($code): *(.+)$"
  regex_exact_subcode="^( +)($subcode): *(.+)$"
  cmd1=""
  
  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex_exact_code ]]; then
      cmd1="${BASH_REMATCH[2]}"
      if [[ -z $subcode ]]; then
        echo "$cmd1"
        exit 0
      fi
    elif [[ -n $cmd1 ]]; then
      if [[ $line =~ $regex_exact_subcode ]]; then
        cmd2="${BASH_REMATCH[3]}"
        if [[ $cmd2 =~ ^! ]]; then
          echo "${cmd2:1}"
        else
          echo "$cmd1 $cmd2"
        fi
        exit 0
      fi
    fi
  done < "$config_file"
  
  echo "Error: No such alias: $code $subcode"
  exit 1
}

# :command.function
alf_upgrade_command() {
  # :src/upgrade_command.sh
  exec bash <(curl -s https://raw.githubusercontent.com/DannyBen/alf/master/setup)
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action=$1
  
  case $action in
  -* )
    ;;
  
  connect | c )
    action="connect"
    shift
    alf_connect_parse_requirements "$@"
    shift $#
    ;;    
  
  download | d )
    action="download"
    shift
    alf_download_parse_requirements "$@"
    shift $#
    ;;    
  
  upload | u )
    action="upload"
    shift
    alf_upload_parse_requirements "$@"
    shift $#
    ;;    
  
  generate | g )
    action="generate"
    shift
    alf_generate_parse_requirements "$@"
    shift $#
    ;;    
  
  save | s )
    action="save"
    shift
    alf_save_parse_requirements "$@"
    shift $#
    ;;    
  
  edit | e )
    action="edit"
    shift
    alf_edit_parse_requirements "$@"
    shift $#
    ;;    
  
  which | w )
    action="which"
    shift
    alf_which_parse_requirements "$@"
    shift $#
    ;;    
  
  upgrade )
    action="upgrade"
    shift
    alf_upgrade_parse_requirements "$@"
    shift $#
    ;;    
  
  * )
    alf_usage
    exit 1
    ;;
  
  esac
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_connect_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_connect_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="connect"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[repo]=$1
    shift
  else
    printf "missing required argument: REPO\nusage: alf connect REPO [options]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
    # :flag.case
    --ssh )
      args[--ssh]=1
      shift
      ;;
  
    # :flag.case
    --https )
      args[--https]=1
      shift
      ;;
  
    # :flag.case
    --yes | -y )
      args[--yes]=1
      shift
      ;;
  
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[repo]} ]]; then
        args[repo]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_download_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_download_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="download"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_upload_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_upload_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="upload"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_generate_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_generate_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="generate"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_save_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_save_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="save"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_edit_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_edit_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="edit"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_which_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_which_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="which"
  # :command.required_args_filter
  if [[ $1 && $1 != -* ]]; then
    args[code]=$1
    shift
  else
    printf "missing required argument: CODE\nusage: alf which CODE [SUBCODE]\n"
    exit 1
  fi
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      if [[ ! ${args[code]} ]]; then
        args[code]=$1
        shift
      elif [[ ! ${args[subcode]} ]]; then
        args[subcode]=$1
        shift
      else
        printf "invalid argument: %s\n" "$key"
        exit 1
      fi
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.parse_requirements
alf_upgrade_parse_requirements() {
  # :command.fixed_flag_filter
  case "$1" in
  --version | -v )
    version_command
    exit
    ;;
  
  --help | -h )
    long_usage=yes
    alf_upgrade_usage
    exit 1
    ;;
  
  esac
  # :command.environment_variables_filter
  # :command.dependencies_filter
  # :command.command_filter
  action="upgrade"
  # :command.required_args_filter
  # :command.required_flags_filter
  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
  
    -* )
      printf "invalid option: %s\n" "$key"
      exit 1
      ;;
  
    * )
      # :command.parse_requirements_case
      printf "invalid argument: %s\n" "$key"
      exit 1
      ;;
  
    esac
  done
  # :command.default_assignments
}

# :command.initialize
initialize() {
  version="0.4.3"
  long_usage=''
  set -e  

  # :src/initialize.sh
  aliases_file=${ALF_ALIASES_FILE:=~/.bash_aliases}
  rc_file=${ALF_RC_FILE:=~/.alfrc}
  set -e
}

# :command.run
run() {
  declare -A args
  parse_requirements "$@"

  if [[ $action == "connect" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_connect_usage
    else
      alf_connect_command
    fi
  
  elif [[ $action == "download" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_download_usage
    else
      alf_download_command
    fi
  
  elif [[ $action == "upload" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_upload_usage
    else
      alf_upload_command
    fi
  
  elif [[ $action == "generate" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_generate_usage
    else
      alf_generate_command
    fi
  
  elif [[ $action == "save" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_save_usage
    else
      alf_save_command
    fi
  
  elif [[ $action == "edit" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_edit_usage
    else
      alf_edit_command
    fi
  
  elif [[ $action == "which" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_which_usage
    else
      alf_which_command
    fi
  
  elif [[ $action == "upgrade" ]]; then
    if [[ ${args[--help]} ]]; then
      long_usage=yes
      alf_upgrade_usage
    else
      alf_upgrade_command
    fi
  
  elif [[ ${args[--version]} ]]; then
    version_command
  elif [[ ${args[--help]} ]]; then
    long_usage=yes
    alf_usage
  elif [[ $action == "root" ]]; then
    root_command
  fi
}

initialize
run "$@"
