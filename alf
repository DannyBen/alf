#!/usr/bin/env bash
# This script was generated by bashly 1.1.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
alf_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf - Your Little Bash Alias Friend\n"
    echo

  else
    printf "alf - Your Little Bash Alias Friend\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf COMMAND\n"
  printf "  alf [COMMAND] --help | -h\n"
  printf "  alf --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "$(bold "Commands:")"
  printf "  %s   Connect to a remote git repository.\n" "$(green "connect") "
  printf "  %s   Perform git pull on the connected repo.\n" "$(green "download")"
  printf "  %s   Perform git commit and push on the connected repo.\n" "$(green "upload")  "
  printf "  %s   Generate aliases to stdout.\n" "$(green "generate")"
  printf "  %s   Generate aliases to \`~/.bash_aliases\`.\n" "$(green "save")    "
  printf "  %s   Open your \`alf.conf\` for editing.\n" "$(green "edit")    "
  printf "  %s   Show the alias command.\n" "$(green "which")   "
  printf "  %s   Upgrade alf to the latest version.\n" "$(green "upgrade") "
  printf "  %s   Show all alf related system facts.\n" "$(green "info")    "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "ALF_RC_FILE"
    printf "    Path to alfrc file.\n    \n    This file holds the path to the alf-conf repository.\n    \n    Default: \`~/.alfrc\`\n"
    echo

  fi
}

# :command.usage
alf_connect_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf connect - Connect to a remote git repository.\n"
    echo

  else
    printf "alf connect - Connect to a remote git repository.\n"
    echo

  fi

  printf "Alias: c\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf connect REPO [OPTIONS]\n"
  printf "  alf connect --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--ssh"
    printf "    Connect to GitHub non-interactively using SSH (implies \`--yes\`).\n"
    echo

    # :flag.usage
    printf "  %s\n" "--https"
    printf "    Connect to GitHub non-interactively using HTTPS (implies \`--yes\`).\n"
    echo

    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Connect to any remote repository non-interactively.\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "REPO"
    printf "    Remote GitHub repository to connect to.\n    \n    Can be one of:\n    \n    - Your username on GitHub.\n      In this case, the repository is expected to be named \`alf-conf\`.\n    - Your username/repo on GitHub.\n    - Any other full URL to a repository.\n"
    echo

    # :command.usage_examples
    printf "%s\n" "$(bold "Examples:")"
    printf "  alf connect you --ssh\n"
    printf "  alf connect you/alf-config\n"
    printf "  alf connect https://You@bitbucket.org/YourUser/rush-repo.git --yes\n"
    echo

  fi
}

# :command.usage
alf_download_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf download - Perform git pull on the connected repo.\n"
    echo

  else
    printf "alf download - Perform git pull on the connected repo.\n"
    echo

  fi

  printf "Alias: d, pull\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf download\n"
  printf "  alf download --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_upload_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf upload - Perform git commit and push on the connected repo.\n"
    echo

  else
    printf "alf upload - Perform git commit and push on the connected repo.\n"
    echo

  fi

  printf "Alias: u, push\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf upload\n"
  printf "  alf upload --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_generate_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf generate - Generate aliases to stdout.\n"
    echo

  else
    printf "alf generate - Generate aliases to stdout.\n"
    echo

  fi

  printf "Alias: g\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf generate\n"
  printf "  alf generate --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_save_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf save - Generate aliases to \`~/.bash_aliases\`.\n"
    echo

  else
    printf "alf save - Generate aliases to \`~/.bash_aliases\`.\n"
    echo

  fi

  printf "Alias: s\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf save\n"
  printf "  alf save --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "$(bold "Environment Variables:")"

    # :environment_variable.usage
    printf "  %s\n" "ALF_ALIASES_FILE"
    printf "    Path to bash_aliases file.\n    \n    Aliases will be saved to this file.\n    \n    Default: \`~/.bash_aliases\`\n"
    echo

  fi
}

# :command.usage
alf_edit_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf edit - Open your \`alf.conf\` for editing.\n"
    echo

  else
    printf "alf edit - Open your \`alf.conf\` for editing.\n"
    echo

  fi

  printf "Alias: e\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf edit\n"
  printf "  alf edit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_which_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf which - Show the alias command.\n"
    echo

  else
    printf "alf which - Show the alias command.\n"
    echo

  fi

  printf "Alias: w\n"
  echo

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf which CODE [SUBCODE]\n"
  printf "  alf which --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "$(bold "Arguments:")"

    # :argument.usage
    printf "  %s\n" "CODE"
    printf "    Show the command for this alias code.\n"
    echo

    # :argument.usage
    printf "  %s\n" "SUBCODE"
    printf "    Show the command for this alias sub-code.\n"
    echo

  fi
}

# :command.usage
alf_upgrade_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf upgrade - Upgrade alf to the latest version.\n"
    echo

  else
    printf "alf upgrade - Upgrade alf to the latest version.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf upgrade\n"
  printf "  alf upgrade --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
alf_info_usage() {
  if [[ -n $long_usage ]]; then
    printf "alf info - Show all alf related system facts.\n"
    echo

  else
    printf "alf info - Show all alf related system facts.\n"
    echo

  fi

  printf "%s\n" "$(bold "Usage:")"
  printf "  alf info\n"
  printf "  alf info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "$(bold "Options:")"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*"
  else
    printf "%b\n" "$*"
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/find_config.sh
find_config() {
  repo_path="$PWD/alf-conf"
  config_file="alf.conf"
  if [[ -f $rc_file ]]; then
    repo_path=$(<"$rc_file")
    config_file=$repo_path/alf.conf
  fi

  if [[ ! -f $config_file ]]; then
    printf "ERROR: Cannot find config file\n\n"
    echo "You should either:"
    echo "- Run this command in a folder with 'alf.conf' file, or"
    echo "- Run 'alf connect' to properly connect to a remote config"
    exit 1
  fi
}

# src/lib/generate_completion.sh
generate_completions() {
  ali1_regex="^([a-z0-9\-]+):"
  ali2_regex="^ +([a-z0-9\-]+):"
  find_config

  echo '# Completions'
  echo 'if command -v complete &> /dev/null ; then'

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $ali1_regex ]]; then
      ali="${BASH_REMATCH[1]}"
      [[ -n $comp ]] && echo "  complete -W $comp"
      comps=""
      comp=""
    elif [[ $line =~ $ali2_regex ]]; then
      if [[ -n $comps ]]; then
        comps="$comps ${BASH_REMATCH[1]}"
      else
        comps="${BASH_REMATCH[1]}"
      fi
      comp="\"$comps\" $ali"
    fi
  done <"$config_file"

  if [[ -n $comp ]] && [[ -n $comps ]]; then
    echo "  complete -W $comp"
  fi

  echo 'fi'
}

# src/lib/generate_config.sh
generate_config() {
  regex="^( *)([a-zA-Z0-9\-]+): *(.+)$"
  state="simple"
  lastcmd=""
  case_open="false"
  find_config

  echo "# This file was automatically generated by alf"
  echo "# https://github.com/dannyben/alf"

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      indent="${BASH_REMATCH[1]}"

      if [[ -z $indent ]]; then
        ali1="${BASH_REMATCH[2]}"
        cmd1="${BASH_REMATCH[3]}"
        local_regex="^$ali1( +|$)"
        if [[ $cmd1 =~ $local_regex ]]; then
          cmd1="command $cmd1"
        fi
        unset ali2 cmd2
        generate_last_cmd
        lastcmd=$cmd1
      else
        ali2="${BASH_REMATCH[2]}"
        cmd2="${BASH_REMATCH[3]}"
      fi

      if [[ -n $ali2 ]]; then
        state="nested"
        if [[ "$case_open" = "false" ]]; then
          echo "  case \"\$1\" in"
          case_open="true"
        fi
        echo "    $ali2)"
        echo "      shift"

        if [[ $cmd2 =~ ^! ]]; then
          cmd=${cmd2:1}
        elif [[ $cmd1 =~ ^! ]]; then
          cmd="$cmd2"
        else
          cmd="$cmd1 $cmd2"
        fi

        if [[ $cmd2 =~ \$ ]]; then
          echo "      $cmd"
        else
          echo "      $cmd \"\$@\""
        fi
        echo "      ;;"
      else
        echo ""
        echo "unalias $ali1 1>/dev/null 2>&1"
        echo "$ali1() {"
      fi
    fi
  done <"$config_file"
  generate_last_cmd

  echo ""
  if has_subcommands; then
    generate_completions
  fi
}

# src/lib/generate_last_cmd.sh
generate_last_cmd() {
  if [[ -n $lastcmd ]]; then
    if [[ $lastcmd =~ ^! ]]; then
      fullcmd="echo this alias requires a subcommand"
    elif [[ $lastcmd =~ \$ ]]; then
      fullcmd=$lastcmd
    else
      fullcmd="$lastcmd \"\$@\""
    fi

    if [[ $state = "simple" ]]; then
      echo "  $fullcmd"
      echo "}"
    else
      echo "    *)"
      echo "      $fullcmd"
      echo "      ;;"
      echo "  esac"
      echo "}"
      state="simple"
      case_open="false"
    fi
  fi
}

# src/lib/has_subcommands.sh
has_subcommands() {
  regex="^ +([a-z0-9\-]+):"
  find_config

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      return 0
    fi
  done <"$config_file"

  return 1
}

# src/lib/save_config.sh
save_config() {
  find_config

  tilde='~'
  friendly_aliases_file="${aliases_file/#$HOME/$tilde}"

  echo "Saving to $aliases_file"
  generate_config >"$aliases_file"

  echo "To apply the new aliases to the current session, run:"
  echo "$ source $friendly_aliases_file"
}

# :command.command_functions
# :command.function
alf_connect_command() {
  # src/connect_command.sh
  repo=${args[repo]}
  force=${args[--yes]}
  force_ssh=${args[--ssh]}
  force_https=${args[--https]}

  if [[ $repo =~ ':' ]]; then
    repo_url=$repo
  elif [[ $repo =~ '/' ]]; then
    partial_github_url=1
    repo_url="$repo.git"
  else
    partial_github_url=1
    repo_url="$repo/alf-conf.git"
  fi

  if [[ $force_ssh ]]; then
    answer=y
    [[ $partial_github_url ]] && repo_url="git@github.com:$repo_url"
    echo "Connecting to $repo_url"

  elif [[ $force_https ]]; then
    answer=y
    [[ $partial_github_url ]] && repo_url="https://github.com/$repo_url"
    echo "Connecting to $repo_url"

  elif [[ $force ]]; then
    if [[ $partial_github_url ]]; then
      echo "Error: Cannot determine the full URL for the repository"
      echo "To connect to GitHub use --ssh or --https"
      echo "To connect to another repository, provide the full URL"
      exit 1
    fi
    answer=y
    echo "Connecting to $repo_url"

  else
    echo "This operation will:"
    echo ""
    if [[ ! -d ./alf-conf ]]; then
      echo "  clone  $repo_url"
      echo "     to  ./alf-conf"
      echo ""
    fi
    echo "  write  $PWD/alf-conf"
    echo "     to  $rc_file"
    echo ""

    if [[ -n "$partial_github_url" ]]; then
      echo "Would you like to connect to GitHub via SSH or HTTPS?"
      echo ""
      printf "[S]SH, [H]TTPS or [A]bort (default): "
      read -r answer

      if [[ $answer =~ [Ss] ]]; then
        repo_url="git@github.com:$repo_url"
        answer=y
        echo ""
        echo "Using $repo_url"
      elif [[ $answer =~ [Hh] ]]; then
        repo_url="https://github.com/$repo_url"
        answer=y
        echo ""
        echo "Using $repo_url"
      fi
    else
      printf "Continue? [yN] "
      read -r answer
    fi
  fi

  if [[ $answer =~ [Yy] ]]; then
    if [[ -d ./alf-conf ]]; then
      echo "Skipping clone, directory already exists"
    else
      git clone "$repo_url" ./alf-conf
    fi
    echo "$PWD/alf-conf" >"$rc_file"
    echo "Storing location in $rc_file"
  else
    echo "Aborting"
    exit
  fi

  save_config

}

# :command.function
alf_download_command() {
  # src/download_command.sh
  find_config

  if [[ ! -f $rc_file ]]; then
    echo "Cannot find $rc_file"
    echo "Please connect alf to a repository first"
    exit 1
  fi

  pushd "$repo_path" >/dev/null
  echo "Pulling from repository to $repo_path"
  git pull
  popd >/dev/null

  save_config
}

# :command.function
alf_upload_command() {
  # src/upload_command.sh
  find_config

  if [[ ! -f $rc_file ]]; then
    echo "Cannot find $rc_file"
    echo "Please connect alf to a repository first"
    exit 1
  fi

  pushd "$repo_path" >/dev/null
  echo "Pushing $repo_path to repository"
  git commit -am "automatic push"
  git push
  popd >/dev/null
}

# :command.function
alf_generate_command() {
  # src/generate_command.sh
  generate_config

}

# :command.function
alf_save_command() {
  # src/save_command.sh
  save_config

}

# :command.function
alf_edit_command() {
  # src/edit_command.sh
  find_config
  ${EDITOR:-vi} "$config_file"
}

# :command.function
alf_which_command() {
  # src/which_command.sh
  code=${args[code]}
  subcode=${args[subcode]}

  find_config
  regex_exact_code="^($code): *(.+)$"
  regex_exact_subcode="^( +)($subcode): *(.+)$"
  cmd1=""

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex_exact_code ]]; then
      cmd1="${BASH_REMATCH[2]}"
      if [[ -z $subcode ]]; then
        echo "$cmd1"
        exit 0
      fi
    elif [[ -n $cmd1 ]]; then
      if [[ $line =~ $regex_exact_subcode ]]; then
        cmd2="${BASH_REMATCH[3]}"
        if [[ $cmd2 =~ ^! ]]; then
          echo "${cmd2:1}"
        else
          echo "$cmd1 $cmd2"
        fi
        exit 0
      fi
    fi
  done <"$config_file"

  echo "Error: No such alias: $code $subcode"
  exit 1

}

# :command.function
alf_upgrade_command() {
  # src/upgrade_command.sh
  exec bash <(curl -s https://raw.githubusercontent.com/DannyBen/alf/master/setup)

}

# :command.function
alf_info_command() {
  # src/info_command.sh
  find_config

  if [[ -d "$repo_path/.git" ]]; then
    pushd "$repo_path" >/dev/null
    remote="$(git config --get remote.origin.url)"
    popd >/dev/null
  else
    remote="unset"
  fi

  if [[ -f "$rc_file" ]]; then
    alfrc_content="exists with '$(<"$rc_file")'"
  else
    alfrc_content="does not exist"
  fi

  if [[ -f "$aliases_file" ]]; then
    bash_aliases_status="exists"
  else
    bash_aliases_status="does not exist"
  fi

  echo "Executable:"
  echo "  path:              $(command -v alf)"
  echo

  echo "Environment:"
  echo "  ALF_RC_FILE:       ${ALF_RC_FILE:-unset}"
  echo "  ALF_ALIASES_FILE:  ${ALF_ALIASES_FILE:-unset}"
  echo

  echo "Paths:"
  echo "  alfrc path:        $rc_file"
  echo "  aliases path:      $aliases_file"
  echo "  repo path:         $repo_path"
  echo "  config path:       $config_file"
  echo

  echo "Files:"
  echo "  alfrc:             $alfrc_content"
  echo "  aliases:           $bash_aliases_status"
  echo

  echo "GitHub:"
  echo "  remote:            $remote"
  echo

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        alf_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    connect | c)
      action="connect"
      shift
      alf_connect_parse_requirements "$@"
      shift $#
      ;;

    download | d | pull)
      action="download"
      shift
      alf_download_parse_requirements "$@"
      shift $#
      ;;

    upload | u | push)
      action="upload"
      shift
      alf_upload_parse_requirements "$@"
      shift $#
      ;;

    generate | g)
      action="generate"
      shift
      alf_generate_parse_requirements "$@"
      shift $#
      ;;

    save | s)
      action="save"
      shift
      alf_save_parse_requirements "$@"
      shift $#
      ;;

    edit | e)
      action="edit"
      shift
      alf_edit_parse_requirements "$@"
      shift $#
      ;;

    which | w)
      action="which"
      shift
      alf_which_parse_requirements "$@"
      shift $#
      ;;

    upgrade)
      action="upgrade"
      shift
      alf_upgrade_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      alf_info_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      alf_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
alf_connect_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_connect_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="connect"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --ssh)

        # :flag.case_no_arg
        args['--ssh']=1
        shift
        ;;

      # :flag.case
      --https)

        # :flag.case_no_arg
        args['--https']=1
        shift
        ;;

      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['repo']+x} ]]; then

          args['repo']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['repo']+x} ]]; then
    printf "missing required argument: REPO\nusage: alf connect REPO [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
alf_download_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_download_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="download"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
alf_upload_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_upload_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="upload"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
alf_generate_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_generate_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="generate"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
alf_save_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_save_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="save"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
alf_edit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_edit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="edit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
alf_which_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_which_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="which"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['code']+x} ]]; then

          args['code']=$1
          shift
        elif [[ -z ${args['subcode']+x} ]]; then

          args['subcode']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['code']+x} ]]; then
    printf "missing required argument: CODE\nusage: alf which CODE [SUBCODE]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
alf_upgrade_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_upgrade_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v curl >/dev/null 2>&1; then
    deps['curl']="$(command -v curl | head -n1)"
  else
    printf "missing dependency: curl\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="upgrade"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
alf_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        alf_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v git >/dev/null 2>&1; then
    deps['git']="$(command -v git | head -n1)"
  else
    printf "missing dependency: git\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.5.1"
  long_usage=''
  set -e

  # src/initialize.sh
  aliases_file=${ALF_ALIASES_FILE:-~/.bash_aliases}
  rc_file=${ALF_RC_FILE:-~/.alfrc}
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "connect") alf_connect_command ;;
    "download") alf_download_command ;;
    "upload") alf_upload_command ;;
    "generate") alf_generate_command ;;
    "save") alf_save_command ;;
    "edit") alf_edit_command ;;
    "which") alf_which_command ;;
    "upgrade") alf_upgrade_command ;;
    "info") alf_info_command ;;
  esac
}

initialize
run "$@"
